#version 450
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

struct Camera {
    int image_width;
    int image_height;

    vec3 horizontal;
    vec3 vertical;

    vec3 lower_left_corner;
    vec3 origin;
};
uniform Camera camera;

struct Ray {
    vec3 origin;
    vec3 direction;
};
vec3 RayAt(Ray r, float t);
vec3 RayColor(Ray r);

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
};

// TODO: 6.13. An Abstraction for Hittable Objects
//       abstraction for hittable on GPU can use 
//       "location aliasing" (https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)#Interface_components)
//       Pad all primitives with the same byte size and specify type using a
//       enum (int). Using the enum we can find out which alias we are using and bring meaning to the struct 
//       data and call the correct method. The negative here is the padding meaning we will waste bytes
//       We can also just keep adding primitives which will bloat our code, but save bytes.  

struct Sphere {
    vec3 center; 
    float radius;
};                     
// Read about std here: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout
layout (std430, binding = 1) buffer SphereBuffer {
    Sphere spheres[];
};
bool HitSphere(Sphere sphere, Ray r, float t_min, float t_max, out HitRecord rec); 

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    float u = float(pixel_coord.x) / (camera.image_width-1);
    float v = float(pixel_coord.y) / (camera.image_height-1);

    vec3 ray_dir = camera.lower_left_corner + u * camera.horizontal + v * camera.vertical - camera.origin;
    Ray ray = Ray(camera.origin, ray_dir);
    vec4 color = vec4(RayColor(ray), 1.0);
    imageStore(img_output, pixel_coord, color);
}

vec3 RayAt(Ray r, float t) {
    return r.origin + r.direction * t;
}

vec3 RayColor(Ray r) {
    HitRecord hit;
    bool did_hit = HitSphere(spheres[0], r, 0.0, 20.0, hit);
    if (did_hit) {
        return 0.5 * vec3(hit.normal.x + 1, hit.normal.y + 1, hit.normal.z + 1);
    }
    
    float t = 0.5 * (normalize(r.direction).y + 1.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

bool HitSphere(Sphere sphere, Ray r, float t_min, float t_max, out HitRecord rec) {
    // calculate vector from sphere to ray origin
    vec3 oc = r.origin - sphere.center; 
    float a = dot(r.direction, r.direction);
    float half_b = dot(oc, r.direction);
    // angle distance between ray and oc 
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    
    float discriminant = half_b * half_b - a * c;
    if (discriminant < 0) {
        return false;
    }

    float sqrt_disc = sqrt(discriminant);
    float root = (-half_b - sqrt_disc ) / a;
    if (root < t_min || t_max < root) {
        // abc formula: https://en.wikipedia.org/wiki/Quadratic_equation#Quadratic_formula_and_its_derivation
        root = (-half_b + sqrt_disc ) / a; 
        if (root < t_min || t_max < root) {
            return false;
        }
    }

    rec.t = root;
    rec.point = RayAt(r, rec.t);
    rec.normal = (rec.point - sphere.center) / sphere.radius;

    return true;
}