#version 450
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

/*
    This code is based on raytracing in one weekend (https://raytracing.github.io/books/RayTracingInOneWeekend.html)
*/

// Constants
// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385

float DegreesToRadians(float deg) {
    return deg * pi / 180.0;
}

float Rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }
float Rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
float Rand(vec3 co){ return Rand(co.xy+Rand(co.z)); }
float Rand(vec2 co, float min, float max) {
    return min + (max - min) * Rand(co);
}
vec3 RandVec3(vec2 co) {
    float x = Rand(co);
    float y = Rand(vec2(co.x + x, co.y + x));
    float z = Rand(vec2(co.x + y, co.y + y));
    return vec3(x, y, z);
}
vec3 RandVec3(vec2 co, float min, float max) {
    float x = Rand(co, min, max);
    float y = Rand(vec2(co.x + x, co.y + x), min, max);
    float z = Rand(vec2(co.x + y, co.y + y), min, max);
    return vec3(x, y, z);
}
vec3 RandUnitVector(vec2 co) {
    return normalize(RandVec3(co, -1, 1));
}
vec3 RandInHemisphere(vec2 co, vec3 normal) {
    vec3 in_unit_sphere = RandVec3(co, -1, 1);
    while (dot(in_unit_sphere, in_unit_sphere) >= 1) {
        in_unit_sphere = RandVec3(co, -1, 1);
    }
    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

struct Ray {
    vec3 origin;
    vec3 direction;
};
Ray CreateRay(vec3 origin, vec3 direction);
vec3 RayAt(Ray r, float t);
vec3 RayColor(Ray r);

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    bool front_face;
};

struct Camera {
    int image_width;
    int image_height;

    vec3 horizontal;
    vec3 vertical;

    vec3 lower_left_corner;
    vec3 origin;

    int samples_per_pixel;
    int max_bounce;
};
uniform Camera camera;
Ray CameraGetRay(Camera camera, float u, float v);


// TODO: 6.13. An Abstraction for Hittable Objects
//       abstraction for hittable on GPU can use 
//       "location aliasing" (https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)#Interface_components)
//       Pad all primitives with the same byte size and specify type using a
//       enum (int). Using the enum we can find out which alias we are using and bring meaning to the struct 
//       data and call the correct method. The negative here is the padding meaning we will waste bytes
//       We can also just keep adding primitives which will bloat our code, but save bytes. It's worth
//       noting that this is not needed if we go for voxels 

struct Sphere {
    vec3 center; 
    float radius;
};                     
// Read about std here: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout
layout (std430, binding = 1) buffer SphereBuffer {
    Sphere spheres[];
};
bool SpheresHit(Ray r, float t_min, float t_max, out HitRecord hit); 
bool SphereHit(Sphere sphere, Ray r, float t_min, float t_max, out HitRecord hit);

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    vec3 color = vec3(0, 0, 0);
    for (int i = 0; i < camera.samples_per_pixel; i++) {
        float x = float(pixel_coord.x);
        float y = float(pixel_coord.y);
        float u = (x + Rand(vec2(x + i, y))) / (camera.image_width - 1);
        float v = (y + Rand(vec2(x, y + i))) / (camera.image_height - 1);
        Ray ray = CameraGetRay(camera, u, v);
        color += RayColor(ray);
    }

    float scale = 1.0 / camera.samples_per_pixel;
    color = clamp(color * scale, 0, 1);
    color = sqrt(color);
    imageStore(img_output, pixel_coord, vec4(color, 1.0));
}

Ray CreateRay(vec3 origin, vec3 direction) {
    return Ray(origin, normalize(direction));
}

vec3 RayAt(Ray r, float t) {
    // t * dir + origin
    return fma(vec3(t), r.direction, r.origin);
}

vec3 RayColor(Ray r) {
    HitRecord hit;
    Ray current_ray = r;

    int loop_count = 0;
    while (loop_count < camera.max_bounce && SpheresHit(current_ray, 0.001, infinity, hit)) {
        loop_count += 1;

        vec3 target = hit.point + hit.normal + RandInHemisphere(vec2(hit.point.xy), hit.normal);
        vec3 ray_dir = target - hit.point;
        current_ray = CreateRay(hit.point, ray_dir);
    }

    if (loop_count == camera.max_bounce) return vec3(0, 0, 0);

    float t = 0.5 * (current_ray.direction.y + 1.0);
    vec3 background_color = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
    return pow(0.5, loop_count) * background_color;
}

Ray CameraGetRay(Camera camera, float u, float v) {
    vec3 ray_dir =  fma(camera.horizontal, vec3(u), camera.lower_left_corner) + fma(vec3(v), camera.vertical, -camera.origin);
    return CreateRay(camera.origin, ray_dir);
}

bool SpheresHit(Ray r, float t_min, float t_max, out HitRecord hit) {
    HitRecord temp_hit;
    bool has_hit = false;
    float closest = t_max;
    for (int i = 0; i < spheres.length(); i++) {
        if (SphereHit(spheres[i], r, t_min, closest, temp_hit)) {
            has_hit = true;
            closest = temp_hit.t;
            hit = temp_hit;
        }
    }

    return has_hit;
} 

bool SphereHit(Sphere sphere, Ray r, float t_min, float t_max, out HitRecord hit) {
    // calculate vector from sphere to ray origin
    vec3 oc = r.origin - sphere.center; 
    float a = dot(r.direction, r.direction);
    float half_b = dot(oc, r.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    
    float discriminant = half_b * half_b - a * c;
    if (discriminant < 0) {
        return false;
    }

    // optimized abc formula: 
    // https://en.wikipedia.org/wiki/Quadratic_equation#Quadratic_formula_and_its_derivation
    float sqrt_disc = sqrt(discriminant);
    float root = (-half_b - sqrt_disc ) / a;
    if (root < t_min || t_max < root) {
        root = (-half_b + sqrt_disc ) / a; 
        if (root < t_min || t_max < root) {
            return false;
        }
    }

    hit.t = root;
    vec3 point = RayAt(r, root);
    hit.point = point;
    vec3 normal = normalize((point - sphere.center) / sphere.radius);
    hit.front_face = dot(r.direction, normal) < 0; 
    hit.normal = normal * (1 - (2 * float(!hit.front_face)));
    return true;
}