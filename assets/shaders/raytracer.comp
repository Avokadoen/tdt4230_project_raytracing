#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

// TODO: Camera uniform and struct, for now we hard code this

// TODO: SOA, modify shader (array size) based on screen size
struct Rays {
    vec3 origin;
    vec3 direction;
};

vec3 RayAt(Rays r, float t);
vec3 RayColor(Rays r);

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    // ALL OF THIS GO IN CAMERA UNIFORM
    const float aspect_ratio = 16.0 / 16.0; 
    const int image_width = 512;
    const int image_height = int(image_width / aspect_ratio);
    float viewport_height = 2.0;
    float viewport_width = aspect_ratio * viewport_height;
    float focal_length = 1.0;

    vec3 origin = vec3(0, 0, 0);
    vec3 horizontal = vec3(viewport_width, 0, 0);
    vec3 vertical = vec3(0, viewport_height, 0);
    vec3 lower_left_corner = origin - horizontal/2 - vertical/2 - vec3(0, 0, focal_length);
    // END OF CAMERA STUFF

    float u = float(pixel_coord.x) / (image_width-1);
    float v = float(pixel_coord.y) / (image_height-1);
    Rays ray = Rays(origin, lower_left_corner + u*horizontal + v*vertical - origin);
    vec4 color = vec4(RayColor(ray), 1.0);
    imageStore(img_output, pixel_coord, color);
}

vec3 RayAt(Rays r, float t) {
    return r.origin + r.direction * t;
}

vec3 RayColor(Rays r) {
    vec3 direction_norm = normalize(r.direction);
    float t = 0.5 * (direction_norm.y + 1.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}