#version 450

layout(local_size_x = 32, local_size_y = 32) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(rgba32f, binding = 1) uniform image3D octree;

/*
    This code is based on raytracing in one weekend (https://raytracing.github.io/books/RayTracingInOneWeekend.html)
*/

// Constants
// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const int MAT_LAMBERTIAN = 0;
const int MAT_METAL = 1;
const int MAT_DIELECTRIC = 2;

const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385

bool IsNearZero(vec3 v) {
    const float s = 0.000001;
    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);
}

float Rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }
float Rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
float Rand(vec3 co){ return Rand(co.xy+Rand(co.z)); }
float Rand(vec2 co, float min, float max) {
    return min + (max - min) * Rand(co);
}
vec3 RandVec3(vec2 co) {
    float x = Rand(co);
    float y = Rand(vec2(co.x + x, co.y + x));
    float z = Rand(vec2(co.x + y, co.y + y));
    return vec3(x, y, z);
}
vec3 RandVec3(vec2 co, float min, float max) {
    float x = Rand(co, min, max);
    float y = Rand(vec2(co.x + x, co.y + x), min, max);
    float z = Rand(vec2(co.x + y, co.y + y), min, max);
    return vec3(x, y, z);
}
vec3 RandUnitVector(vec2 co) {
    return normalize(RandVec3(co, -1, 1));
}
vec3 RandInHemisphere(vec2 co, vec3 normal) {
    vec3 in_unit_sphere = RandVec3(co, -1, 1);
    while (dot(in_unit_sphere, in_unit_sphere) >= 1) {
        in_unit_sphere = RandVec3(co, -1, 1);
    }
    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

struct Ray {
    vec3 origin;
    vec3 direction;
};
Ray CreateRay(vec3 origin, vec3 direction);
vec3 RayAt(Ray r, float t);
vec3 RayColor(Ray r);

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    int index; 
    bool front_face;
};

struct Camera {
    int image_width;
    int image_height;

    vec3 horizontal;
    vec3 vertical;

    vec3 lower_left_corner;
    vec3 origin;

    int samples_per_pixel;
    int max_bounce;
};
uniform Camera camera;
Ray CameraGetRay(Camera camera, float u, float v);

// TODO: uniform:
const vec3 octree_min = vec3(-1.0, -1.0, -3.2); 
const float octree_scale = 2.0; // world scale
const float octree_n = 2.0; // size in any axis
const int octree_max_depth = 1;
const vec3 octree_inv_indirect_pools = vec3(1.0); // TODO #define // S = count(indirection pools)

// Simple(shallow) fake texture
const vec4 a[2] = vec4[2](vec4(1.0, 0.0, 0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0)); 
const vec4 b[2] = vec4[2](vec4(0.0), vec4(0.0)); 
const vec4 octree_fake_texture[2][2][2] = vec4[2][2][2](vec4[2][2](a, b), vec4[2][2](b, b));


// 1 depth fake texture
// const vec4 double_parent[2] = vec4[2](vec4(1.0, 0.0, 0.0, 0.5), vec4(2.0, 0.0, 0.0, 0.5));
// const vec4 double_leaf[2] = vec4[2](vec4(1.0, 0.0, 0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0)); 
// const vec4 empty[2] = vec4[2](vec4(0.0), vec4(0.0)); 
// const vec4 octree_fake_texture[6][2][2] = vec4[6][2][2](
//     vec4[2][2](double_parent, empty), vec4[2][2](empty, empty),         // first cell
//     vec4[2][2](double_leaf, double_leaf), vec4[2][2](double_leaf, double_leaf),     // second cell
//     vec4[2][2](double_leaf, double_leaf), vec4[2][2](double_leaf, double_leaf)      // third cell
// );



// Octree methods
bool OctreeHit(Ray r, float t_min, float t_max, out HitRecord hit);
bool CubeHit(vec3 cmin, float size, Ray r, float t_min, inout float t_max, out HitRecord hit);

struct Sphere {
    vec3 center; 
    float radius;
    // float as all data is in the same vbo,
    // materials should be limited anyways so this should not 
    // cause too much problems (famous last words?)
    float material_index; 

    // TODO: find use for these floats. Could just include albedo since
    //       we need 3 floats anyways. One problem here is that using a vec3
    //       does not work (link below talks about vendors not implementing vec3)
    //       in this context properly).
    // According to link below this should not be needed ...
    float padding1;
    float padding2;
    float padding3;
};                    
// Read about std here: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout
layout (std430, binding = 0) buffer SphereBuffer {
    Sphere spheres[];
};
vec3 SphereAlbedo(int index);
bool SpheresHit(Ray r, float t_min, float t_max, out HitRecord hit); 
bool SphereHit(int index, Ray r, float t_min, float t_max, out HitRecord hit);

struct Material {
    int type;
    int attribute_index;
    int albedo_index;
};
layout (std430, binding = 1) buffer MaterialBuffer {
    Material materials[];
};
bool ScatterLambertian(int index, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered);
bool ScatterMetal(int index, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered);
bool ScatterDielectric(int index, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered);

struct Albedo {
    vec3 color;
};
layout (std430, binding = 2) buffer AlbedoBuffer {
    Albedo albedos[];
};
struct Metal {
    float fuzz;
};
layout (std430, binding = 3) buffer MetalBuffer {
    Metal metal[];
};
struct Dielectric {
    float ir;
};
layout (std430, binding = 4) buffer DielectricBuffer {
    Dielectric dielectric[];
};

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    vec3 color = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < camera.samples_per_pixel; i++) {
        float x = float(pixel_coord.x);
        float y = float(pixel_coord.y);
        float u = (x + Rand(vec2(x + i, y))) / (camera.image_width - 1);
        float v = (y + Rand(vec2(x, y + i))) / (camera.image_height - 1);
        Ray ray = CameraGetRay(camera, u, v);
        color += RayColor(ray);
    }

    float scale = 1.0 / camera.samples_per_pixel;
    color = clamp(color * scale, 0, 1);
    color = sqrt(color);
    imageStore(img_output, pixel_coord, vec4(color, 1.0));
}

Ray CreateRay(vec3 origin, vec3 direction) {
    return Ray(origin, normalize(direction));
}

vec3 RayAt(Ray r, float t) {
    // t * dir + origin
    return fma(vec3(t), r.direction, r.origin);
}

// TODO: This function has way too much branching for glsl ...
vec3 RayColor(Ray r) {
    HitRecord hit;
    Ray current_ray = r;
    vec3 accumulative_attenuation = vec3(1.0);
    int loop_count = 0;

    while (loop_count < camera.max_bounce && OctreeHit(current_ray, 0.001, infinity, hit)){ 
        loop_count += 1;

        Ray scattered;
        vec3 attenuation;

        bool result = false;
        int m_index = int(spheres[hit.index].material_index);
        switch (materials[m_index].type) {
        case MAT_LAMBERTIAN: 
            result = ScatterLambertian(hit.index, current_ray, hit, attenuation, scattered);
            break;
        case MAT_METAL: 
            result = ScatterMetal(hit.index, current_ray, hit, attenuation, scattered);
            break;
        case MAT_DIELECTRIC:
            result = ScatterDielectric(hit.index, current_ray, hit, attenuation, scattered);
            break;
        default: 
            return vec3(0.0, 0.0, 0.0);
        }
        if (!result) return vec3(0.0);
        
        accumulative_attenuation *= attenuation;
        current_ray = scattered;
    }
    if (loop_count > 0) return accumulative_attenuation;

    float t = 0.5 * (current_ray.direction.y + 1.0);
    vec3 background_color = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
    return background_color;
}

Ray CameraGetRay(Camera camera, float u, float v) {
    vec3 ray_dir =  fma(camera.horizontal, vec3(u), camera.lower_left_corner) + fma(vec3(v), camera.vertical, -camera.origin);
    return CreateRay(camera.origin, ray_dir);
}

vec3 SphereAlbedo(int index) {
    int mat_index = int(spheres[index].material_index);
    Material mat = materials[mat_index];
    return albedos[mat.albedo_index].color;
}

// TODO: this function causes lag spikes for some reason ...
bool CubeHit(vec3 cmin, float size, Ray r, float t_min, inout float t_max, out HitRecord hit) {
    vec3 cmax = cmin + vec3(size);
    for (int i = 0; i < 3; i++) {
        float invD = 1.0 / r.direction[i];
        float t0 = (cmin[i] - r.origin[i]) * invD;
        float t1 = (cmax[i] - r.origin[i]) * invD;
        if (invD < 0.0) {
            float tmp = t0;
            t0 = t1;
            t1 = tmp;
        }

        t_min = max(t0, t_min);
        t_max = min(t1, t_max);

        if (t_max <= t_min) {
            return false;
        }
    }

    hit.t = t_min;
    hit.point = RayAt(r, hit.t);
    // TODO: Hack to compute normal (find a formula for this)
    //       currently too tired, but the answer is probably obvious
    vec3 center = (cmin + cmax) * 0.5;
    vec3 normal = (hit.point - center);
    vec3 abs_norm = abs(normal);
    float keep_x = float(abs_norm.x >= abs_norm.y && abs_norm.x >= abs_norm.z);
    float keep_y = float(abs_norm.y > abs_norm.x && abs_norm.y > abs_norm.z);
    float keep_z = float(abs_norm.z > abs_norm.x && abs_norm.z > abs_norm.y); 
    normal = normalize(vec3(normal.x * keep_x, normal.y * keep_y, normal.z * keep_z));
    hit.front_face = dot(r.direction, normal) < 0; 
    hit.normal = normalize(normal * (1.0 - (2.0 * float(!hit.front_face))));
    hit.index = 0; // TODO: material

    return true;
}

// Octree cell type
const float EMPTY = 0.1;
const float PARENT = 0.5; 
const float LEAF = 0.9;

// float4 tree_lookup(
//     uniform sampler3D IndirPool, // Indirection Pool    
//     uniform float3 invS, // 1 / S    
//     uniform float N,    
//     float3 M) // Lookup coordinates    
// {    
//     float4 I = float4(0.0, 0.0, 0.0, 0.0);    
//     float3 MND = M;      
//     for (float i=0; i<HRDWTREE_MAX_DEPTH; i++) { 
//         // fixed # of iterations        
//         float3 P;      
//         // compute lookup coords. within current node      
//         P = (MND + floor(0.5 + I.xyz * 255.0)) * invS;      
//         // access indirection pool      
//         if (I.w < 0.9) // already in a leaf?          
//             I = (float4)tex3D(IndirPool, P); // no, continue to next depth     
//         if (I.w > 0.9)    // a leaf has been reached          
//             break;  
//         if (I.w < 0.1) // empty cell        
//             discard;      // compute pos within next depth grid   (meaing it should return a signal that this is empty and ray should continue t)    
//         MND = MND * N;    
//     }    
//     return (I);  
// }
// Does a lookup in the texture octree and returns current cell (pixel)
// Should only be use in OctreeHit
vec4 treeLookup(
    vec3 inv_indirect_pools,    // 1 / total amount of pools in octree
    ivec3 voxel_coord,           // point we are doing lookup with in image coordinates
    out ivec3 out_point,
    out int depth 
) {
    vec3 depth_coords = vec3(voxel_coord);
    vec4 cell = vec4(0.0);
    depth = 0;
   
    // ivec3 dimention = imageSize(octree);
    for (float i = 0; i <= octree_max_depth; i++) {
        ivec3 point = ivec3((depth_coords + floor(0.5 + cell.xyz * 255.0)) * inv_indirect_pools);
        vec4 cell = octree_fake_texture[point.x][point.y][point.z];
        if (cell.w <= EMPTY || cell.w >= LEAF) { // if cell is not a parent
            return cell;
        } 

        depth_coords = depth_coords * 2;
        depth = depth + 1;
        out_point = point;
    }
    return cell;
}

ivec3 voxelCoordAt(Ray r, float t) {
    vec3 voxel_coord_f = (((RayAt(r, t) - octree_min) / octree_scale) * octree_n);
    return ivec3(floor(voxel_coord_f));
}

// Traverse octree and check for hits in leaf nodes
bool OctreeHit(Ray r, float t_min, float t_max, out HitRecord hit) {

    
    // retrieve octree bound at hit point
    HitRecord oc_hit;
    vec4 cell = vec4(0.0);
    vec3 c_min = octree_min;
    float c_scale = octree_scale;

    // record t size of octree, return if ray do not go through octree
    float t_octree_max = t_max;
    if(!CubeHit(c_min, c_scale, r, t_min, t_octree_max, oc_hit)) {
        return false;
    } 
    float t_stride = oc_hit.t;

    // while cell is empty and we are hitting octree with ray
    int max_iter = 30; // TODO: uniform
    int current_iter = 0;
    while (cell.w < LEAF && current_iter < max_iter) {
        ivec3 voxel_coord = voxelCoordAt(r, t_stride + 0.0001);
        if (voxel_coord.x > octree_max_depth + 0.99 || 
            voxel_coord.y > octree_max_depth + 0.99 || 
            voxel_coord.z > octree_max_depth + 0.99 ||
            voxel_coord.x < 0 || voxel_coord.y < 0 || voxel_coord.z < 0
        ) {
            break;
        }
        ivec3 point;
        int depth = 0; 

        cell = treeLookup(octree_inv_indirect_pools, voxel_coord, point, depth);
        // cell = octree_fake_texture[voxel_coord.x][voxel_coord.y][voxel_coord.z];
        if (cell.w >= LEAF)
            break;

        c_scale = octree_scale / (1 + depth); 
        c_min = octree_min + voxel_coord;
        
        t_stride = t_octree_max;
        !CubeHit(c_min, c_scale, r, t_min, t_stride, oc_hit);

        current_iter += 1;
    }
    
    if (cell.w >= LEAF) {
        hit = oc_hit;
        return true;
    }
    return false;
}

bool SpheresHit(Ray r, float t_min, float t_max, out HitRecord hit) {
    HitRecord temp_hit;
    bool has_hit = false;
    float closest = t_max;
    for (int i = 0; i < spheres.length(); i++) {
        if (SphereHit(i, r, t_min, closest, temp_hit)) {
            has_hit = true;
            closest = temp_hit.t;
            hit = temp_hit;
        }
    }

    return has_hit;
} 

bool SphereHit(int index, Ray r, float t_min, float t_max, out HitRecord hit) {
    // calculate vector from sphere to ray origin
    Sphere sphere = spheres[index];
    vec3 oc = r.origin - sphere.center; 
    float a = dot(r.direction, r.direction);
    float half_b = dot(oc, r.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    
    float discriminant = half_b * half_b - a * c;
    if (discriminant < 0) {
        return false;
    }

    // optimized abc formula: 
    // https://en.wikipedia.org/wiki/Quadratic_equation#Quadratic_formula_and_its_derivation
    float sqrt_disc = sqrt(discriminant);
    float root = (-half_b - sqrt_disc ) / a;
    if (root < t_min || t_max < root) {
        root = (-half_b + sqrt_disc ) / a; 
        if (root < t_min || t_max < root) {
            return false;
        }
    }

    hit.t = root;
    vec3 point = RayAt(r, root);
    hit.point = point;
    vec3 normal = normalize((point - sphere.center) / sphere.radius);
    hit.front_face = dot(r.direction, normal) < 0; 
    hit.normal = normalize(normal * (1 - (2 * float(!hit.front_face))));
    hit.index = index;
    return true;
}

bool ScatterLambertian(int index, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered) {
    vec3 scatter_dir = hit.normal + RandInHemisphere(hit.point.xy, hit.normal);
    if (IsNearZero(scatter_dir)) scatter_dir = hit.normal;
    scattered = CreateRay(hit.point, scatter_dir);
    attenuation = SphereAlbedo(index);
    return true;
}

bool ScatterMetal(int index, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered) {
    vec3 reflected = reflect(r_in.direction, normalize(hit.normal));
    Material mat = materials[int(spheres[index].material_index)];
    float fuzz = metal[mat.attribute_index].fuzz;
    scattered = CreateRay(hit.point, reflected + fuzz * RandInHemisphere(hit.point.xy, hit.normal));
    attenuation = SphereAlbedo(index);
    return (dot(scattered.direction, hit.normal) > 0);
}

// Sclick Approximation
float reflectance(float cosine, float ref_ratio) {
    float r0 = pow((1 - ref_ratio) / (1 + ref_ratio), 2);
    return fma(pow((1 - cosine), 5), (1 - r0), r0);
}

bool ScatterDielectric(int index, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered) {
    attenuation = vec3(1.0, 1.0, 1.0);
    Material mat = materials[int(spheres[index].material_index)];
    float ir = dielectric[mat.attribute_index].ir;
    float refraction_ratio = ir;
    if(hit.front_face) {
        refraction_ratio = (1.0/ir); 
    } 

    vec3 unit_direction = normalize(r_in.direction);

    float cos_theta = min(dot(-unit_direction, hit.normal), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    vec3 direction;
    bool cannot_refract = refraction_ratio * sin_theta > 1.0;
    bool should_reflect =  reflectance(cos_theta, refraction_ratio) > Rand(hit.point.xy);
    if (cannot_refract || should_reflect) {
        direction = reflect(unit_direction, hit.normal);
    } else {
        direction = refract(unit_direction, hit.normal, refraction_ratio);
    }

    scattered = CreateRay(hit.point, direction);
    return true;
}