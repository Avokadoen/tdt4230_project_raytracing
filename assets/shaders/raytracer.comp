#version 450
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

struct Sphere {
    vec3 pos; 
    float radius;
};                     
// Read about std here: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout
layout (std430, binding = 1) buffer SphereBuffer {
    Sphere spheres[];
};

struct Camera {
    int image_width;
    int image_height;

    vec3 horizontal;
    vec3 vertical;

    vec3 lower_left_corner;
    vec3 origin;
};
uniform Camera camera;

struct Ray {
    vec3 origin;
    vec3 direction;
};
vec3 RayAt(Ray r, float t);
vec3 RayColor(Ray r);
bool HitSphere(Sphere sphere, Ray r);

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    float u = float(pixel_coord.x) / (camera.image_width-1);
    float v = float(pixel_coord.y) / (camera.image_height-1);

    vec3 ray_dir = camera.lower_left_corner + u * camera.horizontal + v * camera.vertical - camera.origin;
    Ray ray = Ray(camera.origin, normalize(ray_dir));
    vec4 color = vec4(RayColor(ray), 1.0);
    imageStore(img_output, pixel_coord, color);
}

vec3 RayAt(Ray r, float t) {
    return r.origin + r.direction * t;
}

vec3 RayColor(Ray r) {
    bool hit_detected = false;
    vec3 hit_color = vec3(1, 0, 0); // default for now
    for (int i = 0; i < spheres.length() && !hit_detected; i++) {
        // TODO: depth, we can't return from this loop as there might be a object closer...
        hit_detected = HitSphere(spheres[i], r);
    }   
    
    float t = 0.5 * (r.direction.y + 1.0);
    vec3 background = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);

    return background * float(!hit_detected) + hit_color * float(hit_detected);
}

bool HitSphere(Sphere sphere, Ray r) {
    // calculate vector from sphere to ray origin
    vec3 oc = r.origin - sphere.pos; 
    // TODO: I have probably misinterpreted this 
    // Source material specifies that a = dot(r.direction, r.direction)
    // but direction is normalized, so this should always be 1. :/
    float a = 1;
    // angle between ray and vector between origin of ray and sphere 
    float b = 2.0 * dot(oc, r.direction);
    // angle distance between ray and oc 
    float c = dot(oc, oc) - pow(sphere.radius, 2);
    
    float discriminant = b * b - 4.0 * a * c;
    return (discriminant > 0);
}